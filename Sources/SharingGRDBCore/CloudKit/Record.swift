import Foundation

// @Table
struct Record {
  var zoneName: String
  var recordName: String
  var recordData: Data?
  var userModificationDate: Date?
}

// NB: This is generated by inlining the above macro applications.
extension Record: StructuredQueriesCore.Table {
  public struct TableColumns: StructuredQueriesCore.TableDefinition {
    public typealias QueryValue = Record
    public let zoneName = StructuredQueriesCore.TableColumn<QueryValue, String>(
      "zoneName",
      keyPath: \QueryValue.zoneName
    )
    public let recordName = StructuredQueriesCore.TableColumn<QueryValue, String>(
      "recordName",
      keyPath: \QueryValue.recordName
    )
    public let recordData = StructuredQueriesCore.TableColumn<QueryValue, Data?>(
      "recordData",
      keyPath: \QueryValue.recordData
    )
    public let userModificationDate = StructuredQueriesCore.TableColumn<QueryValue, Date?>(
      "userModificationDate",
      keyPath: \QueryValue.userModificationDate
    )
    public static var allColumns: [any StructuredQueriesCore.TableColumnExpression] {
      [
        QueryValue.columns.zoneName, QueryValue.columns.recordName, QueryValue.columns.recordData,
        QueryValue.columns.userModificationDate,
      ]
    }
  }
  public static let columns = TableColumns()
  public static let tableName = "records"
  public init(decoder: inout some StructuredQueriesCore.QueryDecoder) throws {
    let zoneName = try decoder.decode(String.self)
    let recordName = try decoder.decode(String.self)
    self.recordData = try decoder.decode(Data.self)
    self.userModificationDate = try decoder.decode(Date.self)
    guard let zoneName else {
      throw QueryDecodingError.missingRequiredColumn
    }
    guard let recordName else {
      throw QueryDecodingError.missingRequiredColumn
    }
    self.zoneName = zoneName
    self.recordName = recordName
  }
}
